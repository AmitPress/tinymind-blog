---
title: Important Problems for DSA
date: 2025-12-29T12:37:43.819Z
---

# ğŸ”¢ Sorting Algorithms
- ğŸ«§ **Bubble Sort** â€” swap neighbors again & again (slow ğŸ¢)
- ğŸ¯ **Selection Sort** â€” pick minimum and place it correctly
- ğŸ§© **Insertion Sort** â€” insert like playing cards â™ ï¸
- âš¡ **Quick Sort** â€” divide by pivot (fast on average ğŸš€)
- ğŸ§¬ **Merge Sort** â€” divide â†’ sort â†’ merge (stable)
- ğŸ—ï¸ **Heap Sort** â€” uses heap data structure
- ğŸ”¢ **Radix Sort** â€” digit-by-digit sorting
- ğŸš **Shell Sort** â€” gap-based insertion sort
- ğŸª£ **Bucket Sort** â€” distribute into buckets, then sort
- ğŸ§® **Counting Sort** â€” count frequencies (non-comparison)

---

# ğŸ” Searching Algorithms
- ğŸš¶ **Linear Search** â€” check one by one
- ğŸ” **Binary Search** â€” works only on sorted data ğŸ“
- ğŸ¦˜ **Jump Search** â€” jump ahead in fixed blocks
- ğŸ“ˆ **Interpolation Search** â€” predicts position
- ğŸš€ **Exponential Search** â€” expands range exponentially
- ğŸ”— **Sublist Search** â€” find linked list inside another
- ğŸ§  **Boyerâ€“Moore Algorithm** â€” smart string skipping
- ğŸ” **Rabinâ€“Karp Algorithm** â€” hashing + string matching
- ğŸ—‚ï¸ **Hashing** â€” O(1) average lookup
- ğŸ”º **Ternary Search** â€” split into three parts

---

# ğŸ§  Divide and Conquer
- ğŸ” **Binary Search** â€” split & conquer
- ğŸ§¬ **Merge Sort** â€” recursive merging
- âš¡ **Quick Sort** â€” partition around pivot
- ğŸ“ **Closest Pair of Points** â€” geometry problem
- ğŸ§® **Strassenâ€™s Matrix Multiplication** â€” faster matrix multiply
- âœ–ï¸ **Karatsuba Multiplication** â€” fast large number multiplication
- ğŸ“‰ **Maximum Subarray Problem** â€” Kadane + D&C
- ğŸŒŠ **FFT (Fast Fourier Transform)** â€” signal processing
- ğŸ”„ **Counting Inversions** â€” measure disorder
- ğŸ—¼ **Tower of Hanoi** â€” classic recursion puzzle

---

# ğŸ’° Greedy Algorithms
- ğŸ—“ï¸ **Activity Selection Problem** â€” max non-overlapping tasks
- ğŸ’ **Fractional Knapsack** â€” take fractions
- ğŸ”¤ **Huffman Coding** â€” optimal compression
- ğŸ§‘â€ğŸ’¼ **Job Scheduling Problem** â€” maximize profit
- ğŸŒ² **Primâ€™s Algorithm** â€” minimum spanning tree
- ğŸ›£ï¸ **Dijkstraâ€™s Algorithm** â€” shortest path (no negative edges)
- ğŸ”— **Kruskalâ€™s Algorithm** â€” MST using sorting + union-find

---

# ğŸ§® Dynamic Programming (DP)
- ğŸ’ **0/1 Knapsack** â€” pick or skip
- â™¾ï¸ **Unbounded Knapsack** â€” unlimited items
- ğŸ’° **Coin Change** â€” number of ways / min coins
- ğŸª¢ **Rope Cutting** â€” maximize product
- ğŸ”— **LCS (Longest Common Subsequence)** â€” string matching
- ğŸ“ˆ **LIS (Longest Increasing Subsequence)** â€” sequence DP
- ğŸ”¢ **MCM (Matrix Chain Multiplication)** â€” parenthesization
- ğŸš¦ **Bellmanâ€“Ford** â€” shortest path (negative edges allowed)
- ğŸŒ **Floydâ€“Warshall** â€” all-pairs shortest path
